#!/bin/bash

[ -z "$GIT_SYNC_SUMMARY" ] && which git-changes >/dev/null 2>&1 && GIT_SYNC_SUMMARY="git changes --no-pager --no-ignores "
function syncdir
{
    cd "$1"
    local rc=0
    local SYNC_SUMMARY_START=`git rev-parse HEAD`
    local SYNC_SUMMARY_END="HEAD"

    GITDIR=`git rev-parse --git-dir`
    if [ -z "$GITDIR" ] && which lsdev.pl >/dev/null 2>&1; then
        SRCDIR=`lsdev.pl -b src -tp -l`
        if [ -d "$SRCDIR/.git" ]; then
            GITDIR="$SRCDIR/.git"
        fi
    fi
    if [ -z "$GITDIR" ]; then
        echo "Not a git tree!"
        return
    fi
    ROOTDIR=`cd $GITDIR/.. && pwd`

    cd "$ROOTDIR"
    stashed=
    if [ -n "$autostash" ] && [ -n "`git status -s -uno 2>/dev/null`" ]; then
        stashed=1
        ignore_marker=`git ignore marker 2>/dev/null`
        git commit -a -m "${ignore_marker}git-sync" --allow-empty
    fi
    if [ -n "$check" ]; then
        local_sha=`git rev-parse HEAD`
        check_origin=`echo "$check" | cut -d'/' -f1`
        check_branch=`echo "$check" | cut -d'/' -f2`
        for remote_sha in $(git ls-remote $check_origin | grep "refs/heads/${check_branch}$" | cut -f1); do
            echo "Trying: $remote_sha :: $local_sha"
            if ! git merge-base --is-ancestor "$remote_sha" "$local_sha" >/dev/null 2>&1; then
                rc=1
                break
            fi
        done
        if [ "$rc" = "1" ]; then
            echo "$ROOTDIR: not up to date [$check]"
        else
            echo "$ROOTDIR: up to date [$check]"
        fi
    elif [ -d "$GITDIR/refs/remotes/p4" ]; then
        git p4 sync
    elif git config -l | grep "^svn-remote" --quiet; then
        git svn update
    else
        git pull
        if which git-tracking >/dev/null 2>&1; then
            SYNC_SUMMARY_END=`git tracking`
            if [ -z "$SYNC_SUMMARY_END" ]; then
                GIT_SYNC_SUMMARY=
            else
                SYNC_SUMMARY_START=`git merge-base ${SYNC_SUMMARY_END} ${SYNC_SUMMARY_START}`
            fi
        fi
    fi
    if [ -f "$ROOTDIR/.gitmodules" ]; then
        git submodule update --init
    fi
    if [ -n "$stashed" ]; then
        git reset HEAD~
    fi
    [ -n "$GIT_SYNC_SUMMARY" ] && $GIT_SYNC_SUMMARY ${SYNC_SUMMARY_START}..${SYNC_SUMMARY_END} 2>/dev/null
    return $rc
}

idx=0
check=
autostash=0
if [ "`git config sync.autostash`" != "false" ]; then
    autostash=1
fi
while [ -n "$1" ]; do
    case "$1" in
        -c|--check)
            shift
            check="$1"
            [ -z "$check" ] && check=$(git rev-parse --abbrev-ref @{u})
            echo "$check" | grep -vq '/' && check="$check/`git name-rev HEAD | cut -d' ' -f2`"
            ;;
        -r|--recursive)
            recursive=1
            ;;
        --no-log)
            GIT_SYNC_SUMMARY=""
            ;;
        --no-color)
            [ -n "$GIT_SYNC_SUMMARY" ] && GIT_SYNC_SUMMARY="$GIT_SYNC_SUMMARY --no-color"
            ;;
        --autostash|-a)
            autostash=1
            ;;
        --no-autostash)
            autostash=
            ;;
        *)
            if [ -d "$1" ]; then
                dirs[$idx]="$1"
                idx=`expr $idx + 1`
            else
                echo "$1 is not a directory"
            fi
            ;;
    esac
    shift
done
if [ $idx -eq 0 ]; then
    idx=1
    dirs[0]=`pwd`
fi

i=0
rc=0
while [ $i -lt $idx ]; do
    root="${dirs[$i]}"
    syncdir "$root" || rc=1
    if [ -n "$recursive" ]; then
        find -L "$root" -mindepth 1 -maxdepth 4 -type d -name ".git" | while read i; do
            sub=`cd $i/.. && pwd`
            if [ "$root" != "$sub" ]; then
                syncdir "$sub" || rc=1
            fi
        done
    fi
    i=`expr $i + 1`
done
exit $rc
