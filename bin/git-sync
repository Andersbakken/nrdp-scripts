#!/bin/bash

GIT_TRACKING=
which git-tracking >/dev/null 2>&1 && GIT_TRACKING=`git-tracking`
MAX=`git config sync.summary-max 2>/dev/null`
[ -z "$GIT_SYNC_SUMMARY" ] && which git-changes >/dev/null 2>&1 && GIT_SYNC_SUMMARY="git changes --no-pager --no-ignores --max=$MAX "
function syncdir
{
    cd "$1"
    local RC=0
    local SYNC_SUMMARY_START=`git rev-parse HEAD 2>/dev/null`
    local SYNC_SUMMARY_END="HEAD"

    GITDIR=`git rev-parse --git-dir 2>/dev/null`
    if [ -z "$GITDIR" ] && which lsdev.pl >/dev/null 2>&1; then
        SRCDIR=`lsdev.pl -b src -tp -l`
        if [ -d "$SRCDIR/.git" ]; then
            GITDIR="$SRCDIR/.git"
        fi
    fi
    if [ -z "$GITDIR" ]; then
        echo "Not a git tree!"
        return
    fi
    ROOTDIR=`git rev-parse --show-toplevel 2>/dev/null`
    if [ -z "$ROOTDIR" ]; then
        echo "Can't find root dir"
        return
    fi

    cd "$ROOTDIR"
    STASHED=
    local PULLARGS=
    local USE_OPERATION=$(git config sync.operation 2>/dev/null)
    [ "$USE_OPERATION" = "true" ] && git operation save --pending
    if [ -n "$AUTOSTASH" ] && [ -n "`git status -s -uno 2>/dev/null`" ]; then
        if [ "$AUTOSTASH" = "pull" ]; then
            PULLARGS="--autostash"
        else
            STASHED="$(git ignore-commit marker sync-autostash 2>/dev/null)git-sync"
            git commit -a -m "${STASHED}" --allow-empty
        fi
    fi

    if [ -n "$CHECK" ]; then
        LOCAL_SHA=`git rev-parse HEAD`
        CHECK_ORIGIN=`echo "$CHECK" | cut -d'/' -f1`
        CHECK_BRANCH=`echo "$CHECK" | cut -d'/' -f2-`
        for REMOTE_SHA in $(git ls-remote $CHECK_ORIGIN | grep "refs/heads/${CHECK_BRANCH}$" | cut -f1); do
            echo "Trying: $REMOTE_SHA :: $LOCAL_SHA"
            if ! git merge-base --is-ancestor "$REMOTE_SHA" "$LOCAL_SHA" >/dev/null 2>&1; then
                RC=1
                break
            fi
        done
        if [ "$RC" = "1" ]; then
            echo "$ROOTDIR: not up to date [$CHECK]"
        else
            echo "$ROOTDIR: up to date [$CHECK]"
        fi
    elif [ -d "$GITDIR/refs/remotes/p4" ]; then
        git p4 sync
    elif git config -l | grep "^svn-remote" --quiet; then
        git svn update
    else
        git pull $PULLARGS
        if [ -n "$GIT_TRACKING" ]; then
            SYNC_SUMMARY_END="${GIT_TRACKING}"
            if [ -z "$SYNC_SUMMARY_END" ]; then
                GIT_SYNC_SUMMARY=
            else
                SYNC_SUMMARY_START=`git merge-base ${SYNC_SUMMARY_END} ${SYNC_SUMMARY_START}`
            fi
        fi

        # Autosquash: rebase with autosquash against merge-base (calculated AFTER pull)
        if [ -n "$AUTOSQUASH" ] && [ ! -f "$GITDIR/REBASE_HEAD" ]; then
            local tracking=$(git rev-parse --abbrev-ref @{u} 2>/dev/null)
            local AUTOSQUASH_BASE=
            [ -n "$tracking" ] && AUTOSQUASH_BASE=$(git merge-base HEAD "$tracking" 2>/dev/null)
            if [ -n "$AUTOSQUASH_BASE" ]; then
                GIT_SEQUENCE_EDITOR=true git rebase -i --autosquash --autostash "$AUTOSQUASH_BASE"
            fi
        fi
    fi
    git remote prune $(echo ${GIT_TRACKING} | cut -d/ -f1)
    if [ -f "$ROOTDIR/.gitmodules" ]; then
        git submodule update --init
    fi

    if [ ! -f "$GITDIR/REBASE_HEAD" ]; then
        if [ -n "$STASHED" ] && [ "$(git show --pretty=format:%s --no-patch)" = "$STASHED" ]; then
            git reset HEAD~
        fi
    fi
    [ "$USE_OPERATION" = "true" ] && git operation pop --pending

    [ -n "$GIT_SYNC_SUMMARY" ] && $GIT_SYNC_SUMMARY ${SYNC_SUMMARY_START}..${SYNC_SUMMARY_END} 2>/dev/null
    return $RC
}

IDX=0
CHECK=
AUTOSTASH=`git config sync.autostash`
if [ "$AUTOSTASH" = "pull" ]; then
    VERSION=`git --version | cut -d' ' -f3`
    if [ `echo $VERSION | awk -F. '{print $1}'` -eq 2 ] && [ `echo $VERSION | awk -F. '{print $2}'` -lt 9 ]; then
        AUTOSTASH=1
    fi
fi
[ "$(git config sync.autosquash)" = "true" ] && AUTOSQUASH=1

while [ -n "$1" ]; do
    case "$1" in
        -c|--check)
            shift
            CHECK="$1"
            [ -z "$CHECK" ] && CHECK=$(git rev-parse --abbrev-ref @{u})
            echo "$CHECK" | grep -vq '/' && CHECK="$CHECK/`git name-rev HEAD | cut -d' ' -f2`"
            ;;
        --no-log)
            GIT_SYNC_SUMMARY=""
            ;;
        --autostash-pull)
            AUTOSTASH=pull
            ;;
        -a=*|--autostash=*)
            AUTOSTASH=`echo $1 | sed -e 's,^[^=]*=,,'`
            ;;
        --no-color)
            [ -n "$GIT_SYNC_SUMMARY" ] && GIT_SYNC_SUMMARY="$GIT_SYNC_SUMMARY --no-color"
            ;;
        --autostash|-a)
            AUTOSTASH=1
            ;;
        --autosquash)
            AUTOSQUASH=1
            ;;
        --no-autostash)
            AUTOSTASH=
            ;;
        *)
            if [ -d "$1" ]; then
                dirs[$IDX]="$1"
                IDX=`expr $IDX + 1`
            else
                echo "$1 is not a directory"
            fi
            ;;
    esac
    shift
done
if [ $IDX -eq 0 ]; then
    IDX=1
    dirs[0]=`pwd`
fi

I=0
RC=0
while [ $I -lt $IDX ]; do
    ROOT="${dirs[$I]}"
    syncdir "$ROOT" || RC=1
    I=`expr $I + 1`
done
exit $RC
