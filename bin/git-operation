#!/usr/bin/env node

const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const { constants } = fs;
const { exec } = require("child_process");
const { promisify } = require("util");

const execAsync = promisify(exec);
const usage =
    "Usage: git operation [save|apply|pop|drop|list|clear|show] [index] [--index <idx>|--index=<idx>] [--no-autocommit] [--force|-f|--overwrite-archive] [--verbose|-v] [--show-same] [--show-different]";

let mode;
let index;
let verbose = () => {};
let showMode = [];

if (
    process.env.GIT_OPERATION_VERBOSE &&
    process.env.GIT_OPERATION_VERBOSE !== "false" &&
    process.env.GIT_OPERATION_VERBOSE !== "0"
) {
    verbose = console.error.bind(console);
}

async function main() {
    for (let i = 2; i < process.argv.length; i++) {
        switch (process.argv[i]) {
            case "--help":
            case "-h":
                console.log(usage);
                process.exit(0);
                break;
            case "--verbose":
            case "-v":
                verbose = console.error.bind(console);
                break;

            case "--index":
                index = parseInt(process.argv[++i]);
                if (index < 0 || isNaN(index)) {
                    die("Invalid index specified. It must be a non-negative integer.");
                }
                break;

            case "save":
            case "apply":
            case "pop":
            case "list":
            case "drop":
            case "clear":
            case "show":
                if (mode) {
                    die("Cannot specify multiple operations.");
                }
                mode = process.argv[i];
                break;

            case "--show-same":
                showMode.push("same");
                break;

            case "--show-different":
                showMode.push("different");
                break;

            default:
                if (index === undefined) {
                    if (process.argv[i].startsWith("--index=")) {
                        const idxStr = process.argv[i].split("=")[1];
                        index = parseInt(idxStr);
                    } else {
                        index = parseInt(process.argv[i]);
                    }
                    if (isNaN(index) || index < 0) {
                        die("Invalid index specified. It must be a non-negative integer.");
                    }
                } else {
                    die(`Unexpected argument '${process.argv[i]}'.`);
                }
        }
    }

    if (!mode) {
        die("No operation specified. Use 'save', 'restore', 'check', 'list', 'drop', or 'clear'.");
    }

    root = await runCommand("git rev-parse --show-toplevel").catch((err) => {
        die("Not a git repository.", err.message);
    });

    gitDir = await fs.promises.realpath(await runCommand('git rev-parse --git-path ""')).catch((err) => {
        die("Could not determine git directory.", err.message);
    });

    if (mode === "apply" || mode === "pop" || mode === "drop" || mode === "show") {
        const ops = await indexes();
        if (index === undefined) {
            index = ops.at(-1);
        }
        if (index === undefined) {
            die("No index specified and no directories found. Use --index <idx> to specify an index.");
        } else if (!ops.includes(index)) {
            die(`index ${index} is out of range ${ops.length ? ops.slice(-1) : ""})`);
        }
    } else if (index !== undefined) {
        die("--index only works for apply|pop|drop|show");
    } else if (mode === "save") {
        index = ((await indexes()).at(-1) ?? 0) + 1;
    }

    verbose({ root, gitDir, mode, index, showMode });

    if (mode === "show") {
        if (!showMode.length) {
            showMode = ["same", "different"];
        }
    } else if (showMode.length) {
        die("--show-same|--show-different only works for show");
    }

    switch (mode) {
        case "save":
            await save();
            break;

        case "list":
            await list();
            break;

        case "drop":
            await drop();
            break;

        case "clear":
            await clear();
            break;

        case "show":
            await show();
            break;

        case "apply":
            await apply();
            break;

        case "pop":
            await apply();
            await drop();
            break;
    }
}

function die(...args) {
    throw new Error(args.join(" "));
}

function isDirectory(path) {
    try {
        const stats = fs.lstatSync(path);
        return stats.isDirectory();
    } catch (err) {
        // Could be ENOENT (doesn't exist), etc.
        return false;
    }
}

async function listFiles(dir) {
    try {
        return await fs.promises.readdir(dir);
    } catch (err) {
        if (err.code === "ENOENT") {
            return [];
        }
        throw err;
    }
}

async function runCommand(command, cwd) {
    try {
        const { stdout } = await execAsync(command, { cwd, maxBuffer: 1024 * 1024 * 16 });
        return stdout.trim();
    } catch (err) {
        const error = new Error(`Command failed: ${command} ${err.message} ${err.code}`);
        error.code = err.code ?? err.errno ?? "EXEC_FAILED";
        error.stderr = err.stderr || "";
        throw error;
    }
}

async function indexes() {
    const ret = await listFiles(path.join(gitDir, "git-operation"));
    return ret.map((x) => parseInt(x)).filter((dir) => dir >= 1 && !isNaN(dir));
}

function processFile(file) {
    // verbose("processFile", file);

    const abs = path.join(root, file);
    const go = () => {
        return new Promise((resolve, reject) => {
            try {
                const hash = crypto.createHash("sha1");
                const stream = fs.createReadStream(abs);

                stream.on("error", (err) => {
                    reject(err);
                });

                stream.on("data", (chunk) => hash.update(chunk));

                stream.on("end", async () => {
                    try {
                        const stats = await fs.promises.stat(abs);
                        resolve({
                            file,
                            sha1: hash.digest("hex"),
                            mtimeMs: Math.round(stats.mtimeMs)
                        });
                    } catch (err) {
                        reject(err);
                    }
                });
            } catch (err) {
                reject(err);
            }
        });
    };

    return go().catch(go);
}

async function save() {
    const files = await Promise.all(
        (await runCommand("git ls-files --others --cached --exclude-standard", root))
            .split("\n")
            .map((x) => {
                if (!x) {
                    return undefined;
                }

                const abs = path.join(root, x);
                if (isDirectory(abs)) {
                    return undefined;
                }

                return x;
            })
            .filter((x) => x)
            .map((file) => processFile(file))
    );
    const dir = path.join(gitDir, "git-operation");
    await fs.promises.mkdir(dir, { recursive: true });
    await fs.promises.writeFile(path.join(dir, String(index)), JSON.stringify(files, undefined, 4));

    await runHook("pre");
}

async function list() {
    const dir = path.join(gitDir, "git-operation");
    console.log(
        (
            await Promise.all(
                (await listFiles(dir)).map(async (x) => {
                    const stats = await fs.promises.stat(path.join(dir, x));
                    const relative = timeAgo(new Date(stats.ctimeMs));
                    return `${x}: ${relative}`;
                })
            )
        ).join("\n")
    );
}

async function drop() {
    const dir = path.join(gitDir, "git-operation");
    const file = path.join(dir, index.toString());
    const list = await indexes();
    await fs.promises.unlink(file);
    for (let i = list.indexOf(index); i < list.length - 1; ++i) {
        const oldName = path.join(dir, String(list[i] + 1));
        const newName = path.join(dir, String(list[i]));
        verbose(`renaming ${oldName} to ${newName}`);
        await fs.promises.rename(oldName, newName);
    }
}

async function apply() {
    let data = await load();
    try {
        await Promise.all(
            data.map(async (x) => {
                if (!x.diff) {
                    // verbose(`${x.file} has the same sha1 and modification time as before`);
                    return;
                }
                if (x.sha1 !== x.diff.sha1) {
                    verbose(`${x.file} has changed. We're leaving its modification time alone`);
                    return;
                }

                verbose(
                    `${x.file} is unchanged. We're changing its mtime from ${prettyTime(x.diff.mtimeMs)} to ${prettyTime(x.mtimeMs)}`
                );
                const abs = path.join(root, x.file);
                await fs.promises.utimes(abs, new Date(x.mtimeMs), new Date(x.mtimeMs));
            })
        );
    } finally {
        runHook("post");
    }
}

async function clear() {
    const dir = path.join(gitDir, "git-operation");
    await fs.promises.rm(dir, { recursive: true, force: true });
}

async function show() {
    let data = await load();
    if (!showMode.includes("same")) {
        data = data.filter((x) => x.diff);
    }

    if (!showMode.includes("different")) {
        data = data.filter((x) => !x.diff);
    }

    console.log(
        data
            .map((x, idx) => {
                const time = `${prettyTime(x.mtimeMs)}${x.diff && x.mtimeMs !== x.diff.mtimeMs ? " *" : ""}`;
                const sha1 = `${x.sha1}${x.diff && x.sha1 !== x.diff.sha1 ? " *" : ""}`;
                const pad = String(data.length).length;
                return `${String(idx).padStart(pad, "")}/${data.length}: file: ${x.file} time: ${time} sha1: ${sha1}`;
            })
            .join("\n")
    );
}

async function load() {
    const file = path.join(gitDir, "git-operation", index.toString());
    const data = JSON.parse(await fs.promises.readFile(file, "utf8"));
    return await Promise.all(
        data.map(async (x) => {
            const realData = await processFile(x.file);
            if (realData.mtimeMs !== x.mtimeMs || realData.sha1 !== x.sha1) {
                x.diff = realData;
            }
            return x;
        })
    );
}

function isExecutable(filePath) {
    try {
        fs.accessSync(filePath, constants.X_OK);
        return true;
    } catch {
        return false;
    }
}

function whichSync(cmd) {
    let ret;
    process.env.PATH.split(":").some((p) => {
        ret = path.join(p, cmd);
        if (isExecutable(ret)) {
            return true;
        }
        ret = undefined;
        return false;
    });
    return ret;
}

function timeAgo(date) {
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);

    const intervals = [
        { label: "year", seconds: 31536000 },
        { label: "month", seconds: 2592000 },
        { label: "week", seconds: 604800 },
        { label: "day", seconds: 86400 },
        { label: "hour", seconds: 3600 },
        { label: "minute", seconds: 60 },
        { label: "second", seconds: 1 }
    ];

    for (const interval of intervals) {
        const count = Math.floor(seconds / interval.seconds);
        if (count >= 1) {
            return `${count} ${interval.label}${count !== 1 ? "s" : ""} ago`;
        }
    }

    return "just now";
}

function prettyTime(ms) {
    const date = new Date(ms);
    return `${date.toISOString()} (${ms}) ${timeAgo(date)}`;
}

function runHook(type) {
    const hook = path.join(gitDir, "hooks", `${type}-operation`);
    if (isExecutable(hook)) {
        verbose(`Running hook: ${hook}`);
        return runCommand(hook, root);
    }
    return Promise.resolve();
}

main().catch((err) => {
    verbose(err.stack);
    console.error(usage);
    console.error(err.message);
    process.exit(1);
});
