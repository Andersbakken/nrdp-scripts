#!/usr/bin/env node

const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const { constants } = fs;
const { exec, spawn } = require("child_process");
const { promisify } = require("util");

const execAsync = promisify(exec);

const usage =
    "Usage: git operation [save|apply|pop|drop|list|clear|show|trim] [index] [--index <idx>|--index=<idx>] [--pending] [--no-autocommit] [--force|-f|--overwrite-archive] [--verbose|-v] [--show-same] [--show-different]";

let mode;
let index;
let isVerbose = false;
let verbose = () => {};
let showMode = [];
let gitDir;
let srcRoot;
let gitHooks;
let autoTrim = 10;
let pending = false;
let needsIndex = false;

if (
    process.env.GIT_OPERATION_VERBOSE &&
    process.env.GIT_OPERATION_VERBOSE !== "false" &&
    process.env.GIT_OPERATION_VERBOSE !== "0"
) {
    isVerbose = true;
}

async function main() {
    let runArgs;
    for (let i = 2; i < process.argv.length; i++) {
        switch (process.argv[i]) {
            case "--help":
            case "-h":
                console.log(usage);
                process.exit(0);
                break;

            case "--verbose":
            case "-v":
                isVerbose = true;
                verbose = console.error.bind(console);
                break;

            case "--index":
                index = parseInt(process.argv[++i]);
                if (index < 0 || isNaN(index)) {
                    die("Invalid index specified. It must be a non-negative integer.");
                }
                break;

            case "apply":
            case "pop":
            case "drop":
            case "show":
            case "trim":
                needsIndex = true;
            case "run":
            case "save":
            case "list":
            case "clear":
                if (mode) {
                    die("Cannot specify multiple operations.");
                }
                mode = process.argv[i];

                if (mode === "run") {
                    runArgs = process.argv.slice(i + 1);
                    if (runArgs.length === 0) {
                        die("run requires a command to execute.");
                    }
                    if (runArgs[0] !== "git") {
                        runArgs.unshift("git");
                    }
                    i = process.argv.length;
                }
                break;

            case "--show-same":
                showMode.push("same");
                break;

            case "--show-different":
                showMode.push("different");
                break;

            case "--pending":
                pending = true;
                break;

            default:
                if (index === undefined && needsIndex) {
                    if (process.argv[i].startsWith("--index=")) {
                        const idxStr = process.argv[i].split("=")[1];
                        index = parseInt(idxStr);
                    } else {
                        index = parseInt(process.argv[i]);
                    }
                    if (isNaN(index) || index < 0) {
                        die("Invalid index specified. It must be a non-negative integer.");
                    }
                } else {
                    die(`Unexpected argument '${process.argv[i]}'.`);
                }
        }
    }

    if (!mode) {
        die("No operation specified. Use 'save', 'restore', 'check', 'list', 'drop', 'clear', 'trim' or 'run'.");
    }

    srcRoot = await runCommand("git rev-parse --show-toplevel").catch((err) => {
        die("Not a git repository.", err.message);
    });

    gitDir = await fs.promises.realpath(await runCommand('git rev-parse --git-path ""')).catch((err) => {
        die("Could not determine git directory.", err.message);
    });

    gitHooks = await runCommand("git rev-parse --git-path hooks").catch((err) => {
        die("Could not determine git hooks directory.", err.message);
    });

    const configAutoTrim = await runCommand("git config operation.autotrim").catch(() => null);
    if (configAutoTrim !== null) {
        const parsed = parseInt(configAutoTrim);
        if (!isNaN(parsed) && parsed >= 0) {
            autoTrim = parsed;
        }
    }

    const pendingMarker = path.join(gitDir, "OPERATION_PENDING");

    if (mode === "apply" || mode === "pop" || mode === "drop" || mode === "show") {
        // For pop/apply --pending, check marker first
        if (pending && (mode === "pop" || mode === "apply")) {
            try {
                const markerContent = await fs.promises.readFile(pendingMarker, "utf8");
                index = parseInt(markerContent.trim());
                if (isNaN(index)) {
                    verbose("Invalid pending marker content, ignoring");
                    process.exit(0);
                }
            } catch (err) {
                if (err.code === "ENOENT") {
                    verbose("No pending operation marker found");
                    process.exit(0);
                }
                throw err;
            }
        }

        const ops = await indexes();
        if (index === undefined) {
            index = ops.at(-1);
        }
        if (index === undefined) {
            die("No index specified and no directories found. Use --index <idx> to specify an index.");
        } else if (!ops.includes(index)) {
            die(`index ${index} is out of range ${ops.length ? ops.slice(-1) : ""}) ${JSON.stringify(ops)}`);
        }
    } else if (mode === "trim") {
        if (index === undefined) {
            die("trim requires a count argument (e.g., 'git operation trim 3')");
        }
    } else if (index !== undefined) {
        die("--index only works for apply|pop|drop|show|trim");
    } else if (mode === "save") {
        index = ((await indexes()).at(-1) ?? 0) + 1;
    }

    verbose({ srcRoot, gitDir, mode, index, showMode });

    if (mode === "show") {
        if (!showMode.length) {
            showMode = ["same", "different"];
        }
    } else if (showMode.length) {
        die("--show-same|--show-different only works for show");
    }

    if (pending && mode !== "save" && mode !== "pop" && mode !== "apply") {
        die("--pending only works with save, apply, or pop");
    }

    switch (mode) {
        case "save":
            await save();
            break;

        case "list":
            await list();
            break;

        case "drop":
            await drop();
            break;

        case "clear":
            await clear();
            break;

        case "show":
            await show();
            break;

        case "apply":
            await apply();
            break;

        case "pop":
            await apply();
            await drop();
            break;

        case "trim":
            await trim();
            break;

        case "run":
            await run(...runArgs);
            break;
    }
}

function die(...args) {
    throw new Error(args.join(" "));
}

function isDirectory(path) {
    try {
        const stats = fs.lstatSync(path);
        return stats.isDirectory();
    } catch (err) {
        // Could be ENOENT (doesn't exist), etc.
        return false;
    }
}

async function listFiles(dir) {
    try {
        return await fs.promises.readdir(dir);
    } catch (err) {
        if (err.code === "ENOENT") {
            return [];
        }
        throw err;
    }
}

async function runCommand(command, cwd) {
    try {
        const { stdout } = await execAsync(command, { cwd, maxBuffer: 1024 * 1024 * 16 });
        return stdout.trim();
    } catch (err) {
        const error = new Error(`Command failed: ${command} ${err.message} ${err.code}`);
        error.code = err.code ?? err.errno ?? "EXEC_FAILED";
        error.stderr = err.stderr || "";
        throw error;
    }
}

async function indexes() {
    const ret = await listFiles(path.join(gitDir, "git-operation"));
    return ret
        .map((x) => parseInt(x))
        .filter((dir) => dir >= 1 && !isNaN(dir))
        .sort((a, b) => a - b);
}

function processFile(file) {
    // verbose("processFile", file);

    const abs = path.join(srcRoot, file);

    const go = () => {
        return new Promise((resolve, reject) => {
            try {
                const hash = crypto.createHash("sha1");
                const stream = fs.createReadStream(abs);

                stream.on("error", (err) => {
                    if (err.code === "ENOENT" || err.code === "EISDIR") {
                        resolve();
                        return;
                    }
                    reject(err);
                });

                stream.on("data", (chunk) => hash.update(chunk));

                stream.on("end", async () => {
                    try {
                        const stats = await fs.promises.stat(abs);
                        resolve({
                            file,
                            sha1: hash.digest("hex"),
                            mtimeMs: Math.round(stats.mtimeMs)
                        });
                    } catch (err) {
                        reject(err);
                    }
                });
            } catch (err) {
                reject(err);
            }
        });
    };

    return go().catch(go);
}

async function save(writeToDisk = true) {
    const files = await Promise.all(
        (await runCommand("git ls-files --others --cached --exclude-standard", srcRoot))
            .split("\n")
            .map((x) => {
                if (!x) {
                    return undefined;
                }

                const abs = path.join(srcRoot, x);
                if (isDirectory(abs)) {
                    return undefined;
                }

                return x;
            })
            .filter((x) => x)
            .map((file) => processFile(file))
            .filter((x) => x)
    );
    if (writeToDisk) {
        const dir = path.join(gitDir, "git-operation");
        await fs.promises.mkdir(dir, { recursive: true });
        await fs.promises.writeFile(path.join(dir, String(index)), JSON.stringify(files, undefined, 4));

        // Create pending marker if --pending flag was used
        if (pending) {
            const pendingMarker = path.join(gitDir, "OPERATION_PENDING");
            await fs.promises.writeFile(pendingMarker, String(index));
            verbose(`Created pending marker for operation ${index}`);
        }
    }

    await runHook("pre");

    // Auto-trim if configured (default 10, 0 disables)
    if (autoTrim > 0) {
        const ops = await indexes();
        if (ops.length > autoTrim) {
            verbose(`Auto-trimming to ${autoTrim} operations`);
            index = autoTrim;
            await trim(true);

            // After trim, the saved entry was renumbered to autoTrim.
            // Update the pending marker so pop --pending finds the right index.
            if (pending) {
                const pendingMarker = path.join(gitDir, "OPERATION_PENDING");
                await fs.promises.writeFile(pendingMarker, String(autoTrim));
                verbose(`Updated pending marker to ${autoTrim}`);
            }
        }
    }
    if (!writeToDisk) {
        return files;
    }
}

async function list() {
    const dir = path.join(gitDir, "git-operation");
    console.log(
        (
            await Promise.all(
                (await listFiles(dir)).map(async (x) => {
                    const fileName = path.join(dir, x);
                    const stats = await fs.promises.stat(fileName);
                    const relative = timeAgo(new Date(stats.ctimeMs));
                    let ret = `${x}: ${relative}`;
                    if (isVerbose) {
                        ret += ` ${fileName} (${stats.size} bytes)`;
                    }
                    return ret;
                })
            )
        ).join("\n")
    );
}

async function drop() {
    const dir = path.join(gitDir, "git-operation");
    const file = path.join(dir, index.toString());
    const list = await indexes();
    await fs.promises.unlink(file);
    for (let i = list.indexOf(index); i < list.length - 1; ++i) {
        const oldName = path.join(dir, String(list[i] + 1));
        const newName = path.join(dir, String(list[i]));
        verbose(`renaming ${oldName} to ${newName}`);
        const stats = await fs.promises.stat(oldName);
        await fs.promises.rename(oldName, newName);
        await fs.promises.utimes(newName, stats.atime, stats.mtime);
    }

    // Remove pending marker if --pending was used
    if (pending) {
        const pendingMarker = path.join(gitDir, "OPERATION_PENDING");
        await fs.promises.unlink(pendingMarker).catch(() => {});
        verbose("Removed pending marker");
    }
}

async function apply(savedData) {
    let data = await load(savedData);
    try {
        await Promise.all(
            data.map(async (x) => {
                if (!x) {
                    return;
                }

                if (!x.diff) {
                    // verbose(`${x.file} has the same sha1 and modification time as before`);
                    return;
                }
                if (x.sha1 !== x.diff.sha1) {
                    verbose(`${x.file} has changed. We're leaving its modification time alone`);
                    return;
                }

                verbose(
                    `${x.file} is unchanged. We're changing its mtime from ${prettyTime(x.diff.mtimeMs)} to ${prettyTime(x.mtimeMs)}`
                );
                const abs = path.join(srcRoot, x.file);
                await fs.promises.utimes(abs, new Date(x.mtimeMs), new Date(x.mtimeMs));
            })
        );
    } finally {
        runHook("post");
    }
}

async function clear() {
    const dir = path.join(gitDir, "git-operation");
    await fs.promises.rm(dir, { recursive: true, force: true });
}

async function trim(quiet = false) {
    const dir = path.join(gitDir, "git-operation");
    const ops = await indexes();
    const keepCount = index;
    const removeCount = ops.length - keepCount;

    if (removeCount <= 0) {
        verbose(`Already at or below ${keepCount} operations (have ${ops.length})`);
        return;
    }

    verbose(`Removing ${removeCount} oldest operations to keep ${keepCount}`);

    // Remove the oldest (lowest index) operations
    for (let i = 0; i < removeCount; i++) {
        const toRemove = ops[i];
        const file = path.join(dir, toRemove.toString());
        verbose(`Removing operation ${toRemove}`);
        await fs.promises.unlink(file);
    }

    // Renumber remaining operations starting from 1
    const remaining = ops.slice(removeCount);
    for (let i = 0; i < remaining.length; i++) {
        const oldIdx = remaining[i];
        const newIdx = i + 1;
        if (oldIdx !== newIdx) {
            const oldName = path.join(dir, oldIdx.toString());
            const newName = path.join(dir, newIdx.toString());
            verbose(`Renaming ${oldIdx} to ${newIdx}`);
            const stats = await fs.promises.stat(oldName);
            await fs.promises.rename(oldName, newName);
            await fs.promises.utimes(newName, stats.atime, stats.mtime);
        }
    }

    if (!quiet) {
        console.log(`Trimmed to ${keepCount} operations (removed ${removeCount})`);
    }
}

async function show() {
    let data = await load();
    if (!showMode.includes("same")) {
        data = data.filter((x) => x.diff);
    }

    if (!showMode.includes("different")) {
        data = data.filter((x) => !x.diff);
    }

    console.log(
        data
            .map((x, idx) => {
                const time = `${prettyTime(x.mtimeMs)}${x.diff && x.mtimeMs !== x.diff.mtimeMs ? " *" : ""}`;
                const sha1 = `${x.sha1}${x.diff && x.sha1 !== x.diff.sha1 ? " *" : ""}`;
                const pad = String(data.length).length;
                return `${String(idx).padStart(pad, "")}/${data.length}: file: ${x.file} time: ${time} sha1: ${sha1}`;
            })
            .join("\n")
    );
}

async function load(data) {
    if (!data) {
        const file = path.join(gitDir, "git-operation", index.toString());
        data = JSON.parse(await fs.promises.readFile(file, "utf8"));
    }

    const results = await Promise.all(
        data.map(async (x) => {
            if (!x) {
                return undefined;
            }
            const realData = await processFile(x.file);
            if (!realData) {
                verbose(`File ${x.file} does not exist, skipping.`);
                return undefined;
            }

            if (realData.mtimeMs !== x.mtimeMs || realData.sha1 !== x.sha1) {
                x.diff = realData;
            }
            return x;
        })
    );
    return results.filter((x) => x);
}

async function run(...args) {
    verbose("calling run with args:", args);
    const saved = await save(false);
    const command = args.join(" ");
    verbose(`Running command: ${command}`);
    let exitCode = 0;
    try {
        exitCode = await new Promise((resolve) => {
            const child = spawn(command, { cwd: srcRoot, shell: true, stdio: "inherit" });
            child.on("close", (code) => resolve(code || 0));
        });
        if (exitCode !== 0) {
            verbose(`Command exited with code ${exitCode}`);
        }
    } finally {
        await apply(saved);
    }
    process.exit(exitCode);
}

function isExecutable(filePath) {
    try {
        fs.accessSync(filePath, constants.X_OK);
        return true;
    } catch {
        return false;
    }
}

function whichSync(cmd) {
    let ret;
    process.env.PATH.split(":").some((p) => {
        ret = path.join(p, cmd);
        if (isExecutable(ret)) {
            return true;
        }
        ret = undefined;
        return false;
    });
    return ret;
}

function timeAgo(date) {
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);

    const intervals = [
        { label: "year", seconds: 31536000 },
        { label: "month", seconds: 2592000 },
        { label: "week", seconds: 604800 },
        { label: "day", seconds: 86400 },
        { label: "hour", seconds: 3600 },
        { label: "minute", seconds: 60 },
        { label: "second", seconds: 1 }
    ];

    for (const interval of intervals) {
        const count = Math.floor(seconds / interval.seconds);
        if (count >= 1) {
            return `${count} ${interval.label}${count !== 1 ? "s" : ""} ago`;
        }
    }

    return "just now";
}

function prettyTime(ms) {
    const date = new Date(ms);
    return `${date.toISOString()} (${ms}) ${timeAgo(date)}`;
}

function runHook(type) {
    const hook = path.join(gitHooks, `${type}-operation`);
    verbose("Checking for hook:", hook, isExecutable(hook) ? "found" : "not found");
    if (isExecutable(hook)) {
        verbose(`Running hook: ${hook}`);
        return runCommand(hook, srcRoot);
    }
    return Promise.resolve();
}

main().catch((err) => {
    verbose(err.stack);
    console.error(usage);
    console.error(err.message);
    process.exit(1);
});
