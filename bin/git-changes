#!/bin/bash

SELF="$GIT_CHANGES_AUTHOR"
[ -z "$SELF" ] && SELF=$(git config user.email)
[ -z "$SELF" ] && SELF=$(whoami)

OPTS=""
AUTHOR=""
IGNORES="1"
PAGER="less -R --quit-if-one-screen"
MERGES="0"
BRANCHES="0"
COUNT_MERGES="0"
NO_COLOR="0"
PATCH="0"
UNKNOWN_OPTS=""
SUBCOMMAND="log"
DEDUPLICATE="0"
PREFIX=""
MAX=
while [ "$#" -gt 0 ]; do
    OPT="$1"
    shift
    case $OPT in
        -r) SUBCOMMAND="reflog" ;;
        -c) SUBCOMMAND="cherry" ;;
        -p) PATCH="1" ;;
        -a) MERGES="1" ;;
        -b) BRANCHES="1" ;;
        -n) MAX="$1"; shift ;;
        -) COUNT_MERGES="1" ;;
        --no-ignores) IGNORES="0" ;;
        --no-pager) PAGER=cat ;;
        --no-merges) MERGES="0" ;;
        -m|--merges) COUNT_MERGES="1" ;;
        --no-color) NO_COLOR="1" ;;
        --deduplicate) DEDUPLICATE="1" ;;
        --prefix) PREFIX="$1"; shift ;;
        -s) AUTHOR="$SELF" ;;
        -u|--author) AUTHOR="$1"; shift ;;
        -t)
            tracking_branch=$(git tracking 2>/dev/null)
            if [ "$?" ]; then
                local_branch=$(git rev-parse --abbrev-ref HEAD)
                OPTS="$OPTS '${tracking_branch}..${local_branch}'"
            fi ;;
        -[0-9]*[Dd]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') days ago'" ;;
        -[0-9]*[Ww]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') weeks ago'" ;;
        -[0-9]*m) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') months ago'" ;;
        -[0-9]*[Yy]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') years ago'" ;;
        -[0-9]*[hH]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') hours ago'" ;;
        -[0-9]*M) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') minutes ago'" ;;
        -[0-9]*[sS]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') seconds ago'" ;;
        -[0-9]*) OPTS="$OPTS -n$(echo $OPT | sed 's,-\([0-9]*\).*,\1,')" ;;
        -n[0-9]*) MAX=$(echo $OPT | sed 's,-n\([0-9]*\).*,\1,') ;;
        --max=*) MAX=$(echo $OPT | sed 's,^[^=]*=,,') ;;
        *) UNKNOWN_OPTS="$UNKNOWN_OPTS $OPT";;
    esac
done

OPTS="$OPTS $UNKNOWN_OPTS"

if [ "$PATCH" = "1" ]; then
    PREFIX="%n%n==============================================================%n${PREFIX}"
    SHOW_PATCH_OPT=""
    [ "$SUBCOMMAND" = "log" ] && OPTS="$OPTS -p"
else
    SHOW_PATCH_OPT="--no-patch"
fi

if [ "$SUBCOMMAND" != "cherry" ]; then
    [ -n "$AUTHOR" ] && OPTS="$OPTS --author='$AUTHOR'"
    if [ "$COUNT_MERGES" = "1" ]; then
        OPTS="$OPTS --merges"
    elif [ "$MERGES" = "0" ]; then
        OPTS="$OPTS --no-merges"
    fi
fi

# Determine if we need per-commit processing (requires hash extraction)
DELIM=$'\x1f'
NEED_PER_COMMIT="0"
[ "$COUNT_MERGES" = "1" ] && NEED_PER_COMMIT="1"
[ "$BRANCHES" = "1" ] && NEED_PER_COMMIT="1"
[ "$IGNORES" = "1" ] && NEED_PER_COMMIT="1"
[ "$PATCH" = "1" ] && [ "$SUBCOMMAND" != "log" ] && NEED_PER_COMMIT="1"

if [ "$NO_COLOR" = "1" ]; then
    COLOR_OPT="--no-color"
    BASE_FORMAT="${PREFIX}%h %s %an %ar %gs"
else
    COLOR_OPT="--color=always"
    BASE_FORMAT="${PREFIX}%C(red)%h%Creset %C(yellow)%s%Creset %C(green)%an%Creset %C(magenta)%ar%Creset %gs"
fi

if [ "$NEED_PER_COMMIT" = "1" ]; then
    PRETTY_ARG="'%x1f%h%x1f${BASE_FORMAT}'"
else
    PRETTY_ARG="'${BASE_FORMAT}'"
fi

{
    if [ "$SUBCOMMAND" = "cherry" ]; then
        CHERRY_UPSTREAM=$(echo $UNKNOWN_OPTS | awk '{print $1}')
        CHERRY_ARGS=$(echo $OPTS | sed 's,\.\., ,g')
        CHERRY_PLUS=$(mktemp)

        # Collect + commits, filtered by author if specified (single git process)
        if [ -n "$AUTHOR" ]; then
            eval git cherry $CHERRY_ARGS | grep '^+' | sed 's,^+ ,,g' | \
                git log --stdin --no-walk --format="%H" --author="$AUTHOR" > "$CHERRY_PLUS"
        else
            eval git cherry $CHERRY_ARGS | grep '^+' | sed 's,^+ ,,g' > "$CHERRY_PLUS"
        fi

        if [ -s "$CHERRY_PLUS" ] && [ "$DEDUPLICATE" = "1" ]; then
            # git cherry only checks the symmetric difference, so it misses
            # equivalent commits that are common ancestors of both branches.
            # Build a map of commit->subject and a set of subjects found in upstream.
            CHERRY_MAP=$(mktemp)
            CHERRY_FOUND=$(mktemp)
            while IFS= read -r c; do
                subj=$(git log -1 --format='%B' "$c" | head -1)
                printf '%s\t%s\n' "$c" "$subj"
            done < "$CHERRY_PLUS" > "$CHERRY_MAP"

            cut -f2 "$CHERRY_MAP" | sort -u | while IFS= read -r subj; do
                [ -n "$subj" ] && [ -n "$(git log -1 --format='%H' --fixed-strings --grep="$subj" "$CHERRY_UPSTREAM")" ] && printf '%s\n' "$subj"
            done > "$CHERRY_FOUND"

            # For squash merges with different messages, check PR ancestry.
            # Find "Merge pull request #N" commits on upstream, fetch their
            # PR head refs, so we can check if + commits are part of merged PRs.
            CHERRY_PR_MAP=$(mktemp)
            pr_nums=$(git log --format="%s" "$CHERRY_UPSTREAM" --grep="^Merge pull request #" | \
                sed -n 's/^Merge pull request #\([0-9]*\).*/\1/p' | sort -un)
            if [ -n "$pr_nums" ]; then
                ls_args=$(echo "$pr_nums" | while read n; do echo "refs/pull/$n/head"; done)
                pr_refs=$(git ls-remote origin $ls_args 2>/dev/null)
                if [ -n "$pr_refs" ]; then
                    # Fetch any PR head objects not already local
                    fetch_refs=""
                    while IFS=$'\t' read -r hash ref; do
                        git cat-file -t "$hash" >/dev/null 2>&1 || fetch_refs="$fetch_refs $ref"
                    done <<< "$pr_refs"
                    [ -n "$fetch_refs" ] && git fetch --quiet origin $fetch_refs 2>/dev/null
                    # Build PR number -> head hash map
                    while IFS=$'\t' read -r hash ref; do
                        pr_num=$(echo "$ref" | sed 's,.*/pull/\([0-9]*\)/.*,\1,')
                        echo "$pr_num $hash"
                    done <<< "$pr_refs" > "$CHERRY_PR_MAP"
                fi
            fi
        fi

        # Display commits not already in upstream
        while IFS= read -r change; do
            if [ "$DEDUPLICATE" = "1" ] && [ -s "$CHERRY_FOUND" ]; then
                subj=$(awk -F'\t' -v h="$change" '$1 == h {print $2}' "$CHERRY_MAP")
                if [ -n "$subj" ] && grep -qxF "$subj" "$CHERRY_FOUND"; then
                    continue
                fi
            fi
            if [ "$DEDUPLICATE" = "1" ] && [ -s "$CHERRY_PR_MAP" ]; then
                # Find PR merge commits on upstream touching the same files
                files=$(git diff-tree --no-commit-id --name-only -r "$change")
                skip=0
                while IFS= read -r pr_msg; do
                    pr_num=$(echo "$pr_msg" | sed -n 's/^Merge pull request #\([0-9]*\).*/\1/p')
                    [ -z "$pr_num" ] && continue
                    pr_head=$(awk -v n="$pr_num" '$1 == n {print $2}' "$CHERRY_PR_MAP")
                    [ -z "$pr_head" ] && continue
                    if git merge-base --is-ancestor "$change" "$pr_head" 2>/dev/null; then
                        skip=1
                        break
                    fi
                done < <(git log --format="%s" "$CHERRY_UPSTREAM" --grep="^Merge pull request #" -- $files)
                [ "$skip" = "1" ] && continue
            fi
            line=$(git show $SHOW_PATCH_OPT $COLOR_OPT --pretty="$BASE_FORMAT" "$change")
            if [ "$COUNT_MERGES" = "1" ]; then
                merged=$(git log --stat "$change^..$change" | grep ^commit | wc -l)
                [ -n "$merged" ] && line="$line ($merged)"
            fi
            if [ "$BRANCHES" = "1" ]; then
                branches=$(git branch -l --contains "$change" | awk '{print $NF}')
                [ -z "$branches" ] && branches=$(git branch -r --contains "$change" | grep 'origin/' | awk '{print $NF}')
                [ -n "$branches" ] && line="$line ($branches)"
            fi
            if [ "$IGNORES" = "1" ]; then
                git ignore-commit check "$change" >/dev/null 2>&1 && line="$line (IGNORED)"
            fi
            echo "$line"
        done < "$CHERRY_PLUS"
        rm -f "$CHERRY_PLUS" "$CHERRY_MAP" "$CHERRY_FOUND" "$CHERRY_PR_MAP"
    elif [ "$NEED_PER_COMMIT" = "1" ]; then
        eval git $SUBCOMMAND $COLOR_OPT --pretty=$PRETTY_ARG $OPTS | while IFS= read -r line; do
            change="${line#*$DELIM}"
            change="${change%%$DELIM*}"
            display="${line#*$DELIM*$DELIM}"
            [ -z "$change" ] && continue
            if [ "$COUNT_MERGES" = "1" ]; then
                merged=$(git log --stat "$change^..$change" | grep ^commit | wc -l)
                [ -n "$merged" ] && display="$display ($merged)"
            fi
            if [ "$BRANCHES" = "1" ]; then
                branches=$(git branch -l --contains "$change" | awk '{print $NF}')
                [ -z "$branches" ] && branches=$(git branch -r --contains "$change" | grep 'origin/' | awk '{print $NF}')
                [ -n "$branches" ] && display="$display ($branches)"
            fi
            if [ "$IGNORES" = "1" ]; then
                git ignore-commit check "$change" >/dev/null 2>&1 && display="$display (IGNORED)"
            fi
            echo "$display"
            if [ "$PATCH" = "1" ]; then
                git show --patch --format="" $COLOR_OPT "$change"
            fi
        done
    else
        eval git $SUBCOMMAND $COLOR_OPT --pretty=$PRETTY_ARG $OPTS
    fi
} | {
    if [ -n "$MAX" ]; then
        awk -v max="$MAX" '
            NR <= max { print }
            END {
                remaining = NR - max
                if (remaining > 0)
                    print "... " remaining " additional commits"
            }
        '
    else
        cat
    fi
} | $PAGER
