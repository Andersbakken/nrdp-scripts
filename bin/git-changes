#!/bin/bash

SELF="$GIT_CHANGES_AUTHOR"
[ -z "$SELF" ] && SELF=$(git config user.email)
[ -z "$SELF" ] && SELF=$(whoami)

OPTS=""
AUTHOR=""
IGNORES="1"
PAGER="less -R"
MERGES="0"
BRANCHES="0"
COUNT_MERGES="0"
NO_COLOR="0"
PATCH="0"
UNKNOWN_OPTS=""
SUBCOMMAND="log"
PREFIX=""
MAX=
while [ "$#" -gt 0 ]; do
    OPT="$1"
    shift
    case $OPT in
        -r) SUBCOMMAND="reflog" ;;
        -c) SUBCOMMAND="cherry" ;;
        -p) PATCH="1" ;;
        -a) MERGES="1" ;;
        -b) BRANCHES="1" ;;
        -n) MAX="$1"; shift ;;
        -) COUNT_MERGES="1" ;;
        --no-ignores) IGNORES="0" ;;
        --no-pager) PAGER=cat ;;
        --no-merges) MERGES="0" ;;
        -m|--merges) COUNT_MERGES="1" ;;
        --no-color) NO_COLOR="1" ;;
        --prefix) PREFIX="$1"; shift ;;
        -s) AUTHOR="$SELF" ;;
        -u|--author) AUTHOR="$1"; shift ;;
        -t)
            tracking_branch=$(git tracking 2>/dev/null)
            if [ "$?" ]; then
                local_branch=$(git rev-parse --abbrev-ref HEAD)
                OPTS="$OPTS '${tracking_branch}..${local_branch}'"
            fi ;;
        -[0-9]*[Dd]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') days ago'" ;;
        -[0-9]*[Ww]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') weeks ago'" ;;
        -[0-9]*m) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') months ago'" ;;
        -[0-9]*[Yy]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') years ago'" ;;
        -[0-9]*[hH]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') hours ago'" ;;
        -[0-9]*M) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') minutes ago'" ;;
        -[0-9]*[sS]) OPTS="$OPTS --since='$(echo $OPT | sed 's,-\([0-9]*\).*,\1,') seconds ago'" ;;
        -[0-9]*) OPTS="$OPTS -n$(echo $OPT | sed 's,-\([0-9]*\).*,\1,')" ;;
        -n[0-9]*) MAX=$(echo $OPT | sed 's,-n\([0-9]*\).*,\1,') ;;
        --max=*) MAX=$(echo $OPT | sed 's,^[^=]*=,,') ;;
        *) UNKNOWN_OPTS="$UNKNOWN_OPTS $OPT";;
    esac
done

OPTS="$OPTS $UNKNOWN_OPTS"

if [ "$PATCH" = "1" ]; then
    PREFIX="%n%n==============================================================%n${PREFIX}"
    SHOW_PATCH_OPT=""
    [ "$SUBCOMMAND" = "log" ] && OPTS="$OPTS -p"
else
    SHOW_PATCH_OPT="--no-patch"
fi

if [ "$SUBCOMMAND" != "cherry" ]; then
    [ -n "$AUTHOR" ] && OPTS="$OPTS --author='$AUTHOR'"
    if [ "$COUNT_MERGES" = "1" ]; then
        OPTS="$OPTS --merges"
    elif [ "$MERGES" = "0" ]; then
        OPTS="$OPTS --no-merges"
    fi
fi

# Determine if we need per-commit processing (requires hash extraction)
DELIM=$'\x1f'
NEED_PER_COMMIT="0"
[ "$COUNT_MERGES" = "1" ] && NEED_PER_COMMIT="1"
[ "$BRANCHES" = "1" ] && NEED_PER_COMMIT="1"
[ "$IGNORES" = "1" ] && NEED_PER_COMMIT="1"
[ "$PATCH" = "1" ] && [ "$SUBCOMMAND" != "log" ] && NEED_PER_COMMIT="1"

if [ "$NO_COLOR" = "1" ]; then
    COLOR_OPT="--no-color"
    BASE_FORMAT="${PREFIX}%h %s %an %ar %gs"
else
    COLOR_OPT="--color=always"
    BASE_FORMAT="${PREFIX}%C(red)%h%Creset %C(yellow)%s%Creset %C(green)%an%Creset %C(magenta)%ar%Creset %gs"
fi

if [ "$NEED_PER_COMMIT" = "1" ]; then
    PRETTY_ARG="'%x1f%h%x1f${BASE_FORMAT}'"
else
    PRETTY_ARG="'${BASE_FORMAT}'"
fi

{
    if [ "$SUBCOMMAND" = "cherry" ]; then
        eval git cherry $(echo $OPTS | sed 's,\.\., ,g') | sed 's,^[\+-] ,,g' | while IFS= read -r change; do
            if [ -n "$AUTHOR" ]; then
                commit_author=$(git show --no-patch --pretty="%an %ae" "$change")
              if ! echo "$commit_author" | grep -q "$AUTHOR"; then
                  continue
                fi
            fi
            line=$(git show $SHOW_PATCH_OPT $COLOR_OPT --pretty="$BASE_FORMAT" "$change")
            if [ "$COUNT_MERGES" = "1" ]; then
                merged=$(git log --stat "$change^..$change" | grep ^commit | wc -l)
                [ -n "$merged" ] && line="$line ($merged)"
            fi
            if [ "$BRANCHES" = "1" ]; then
                branches=$(git branch -l --contains "$change" | awk '{print $NF}')
                [ -z "$branches" ] && branches=$(git branch -r --contains "$change" | grep 'origin/' | awk '{print $NF}')
                [ -n "$branches" ] && line="$line ($branches)"
            fi
            if [ "$IGNORES" = "1" ]; then
                git ignore-commit check "$change" >/dev/null 2>&1 && line="$line (IGNORED)"
            fi
            echo "$line"
        done
    elif [ "$NEED_PER_COMMIT" = "1" ]; then
        eval git $SUBCOMMAND $COLOR_OPT --pretty=$PRETTY_ARG $OPTS | while IFS= read -r line; do
            change="${line#*$DELIM}"
            change="${change%%$DELIM*}"
            display="${line#*$DELIM*$DELIM}"
            [ -z "$change" ] && continue
            if [ "$COUNT_MERGES" = "1" ]; then
                merged=$(git log --stat "$change^..$change" | grep ^commit | wc -l)
                [ -n "$merged" ] && display="$display ($merged)"
            fi
            if [ "$BRANCHES" = "1" ]; then
                branches=$(git branch -l --contains "$change" | awk '{print $NF}')
                [ -z "$branches" ] && branches=$(git branch -r --contains "$change" | grep 'origin/' | awk '{print $NF}')
                [ -n "$branches" ] && display="$display ($branches)"
            fi
            if [ "$IGNORES" = "1" ]; then
                git ignore-commit check "$change" >/dev/null 2>&1 && display="$display (IGNORED)"
            fi
            echo "$display"
            if [ "$PATCH" = "1" ]; then
                git show --patch --format="" $COLOR_OPT "$change"
            fi
        done
    else
        eval git $SUBCOMMAND $COLOR_OPT --pretty=$PRETTY_ARG $OPTS
    fi
} | {
    if [ -n "$MAX" ]; then
        awk -v max="$MAX" '
            NR <= max { print }
            END {
                remaining = NR - max
                if (remaining > 0)
                    print "... " remaining " additional commits"
            }
        '
    else
        cat
    fi
} | $PAGER
