#!/bin/bash

if test "x$GIT_SEQUENCE_EDITOR" = "x$0" ; then
    # The script was launched as an $EDITOR from git rebase -i.
    # Modify the pick line to an edit line and just exit.
    rm -f /tmp/preeditcommit$$
    touch /tmp/preeditcommit$$
    rm -f /tmp/posteditcommit$$
    touch /tmp/posteditcommit$$
    grep "^pick " "$1" | while read line; do
        found=
        for change in $CHANGES; do
            if echo $line | grep --quiet "^pick $change"; then
                echo $line >> /tmp/preeditcommit$$
                # >&2 echo "$change"
                found=1
                break
            fi
        done
        if [ -z "$found" ]; then
            echo $line >> /tmp/posteditcommit$$
            echo "---git-submit skipped line--"
        fi
    done
    cat /tmp/preeditcommit$$ /tmp/posteditcommit$$ > "$1"
    rm -f /tmp/preeditcommit$$ /tmp/posteditcommit$$
    exit 0
fi

GITROOT=`git rev-parse --git-dir`
CURRENTBRANCH=`git branch | grep '^\*' | awk '{print $2}' -`
if test "$CURRENTBRANCH" = "(no" ; then
    echo "Not on a valid branch - please check out the correct branch"
    exit 1
fi

TRACKING=`git config --local submit.tracking`
[ -z "$TRACKING" ] && TRACKING=`git tracking`

if [ "$1" = "tracking" ]; then
    if [ -n "$2" ]; then
        git config --local submit.tracking "$2"
    else
        echo "$TRACKING"
    fi
elif [ "$1" = "cs" ]; then
    if ! git sync --check "$TRACKING" >/dev/null 2>&1; then
        echo "Make sure you sync first! [$ORIGIN]" >&2
        exit 1
    fi
    which git-choose-show-change >/dev/null 2>&1 && git-choose-show-change -command submit submit
elif [ "$1" = "changes" ] || [ "$1" = "list" ]; then
    for change in `git cherry $TRACKING | grep '^+ ' | sed 's,^+,,g'`; do
        [ "$change" = "+" ] && continue
        NOTES=
        git ignore-commit check "$change" >/dev/null && NOTES="$NOTES [IGNORED]"
        echo "$(git changes --no-ignores --max-count=1 $change)$NOTES"
    done
else
    BRANCH=
    IN_CHANGES=
    PUSH=yes
    AUTOSTASH=
    AUTODETACH=
    ORIGIN="$TRACKING"
    [ "`git config submit.autostash`" != "false" ] && AUTOSTASH="yes"
    [ "`git config submit.autodetach`" != "false" ] && AUTODETACH="yes"
    while [ "$#" -ge 1 ]; do
        if [ "$1" = "-n" ]; then
            PUSH=no
        elif [ "$1" = "--branch" ]; then
            shift
            BRANCH="$1"
        elif [ "$1" = "--autostash" ]; then
            AUTOSTASH="yes"
        elif [ "$1" = "--autodetach" ]; then
            AUTODETACH="yes"
        elif [ "$1" = "-a" ]; then
            for change in `git cherry $ORIGIN | grep '^+ ' | sed 's,^+,,g'`; do
                IN_CHANGES="$IN_CHANGES `echo $change | awk '{print $1}'`"
            done
        elif echo "$1" | grep -q / || '!' git rev-parse "$1" >/dev/null 2>&1; then
            ORIGIN="$1"
        else
            IN_CHANGES="$IN_CHANGES $1"
        fi
        shift
    done

    detached=
    if ! git sync --check "$ORIGIN" >/dev/null 2>&1; then
        if [ -n "$AUTODETACH" ]; then
            echo "Upstream has been modified, autodetaching..."
            detached="`git rev-parse --abbrev-ref HEAD`"
            git branch -f submit-autodetach
            git checkout submit-autodetach
            git tracking "$TRACKING"
            if ! git sync; then
                git rebase --abort ### this assumes you're autosetup.rebase=true
                git checkout "$detached"
                git branch -D submit-autodetach
                echo "Make sure you sync first! [$ORIGIN]. We had conflicts, gave up..."
                exit 2
            fi
        else
            echo "Make sure you sync first! [$ORIGIN]" >&2
            exit 1
        fi
    fi

    if [ -z "$IN_CHANGES" ]; then
        which git-choose-show-change >/dev/null 2>&1 && git-choose-show-change --reverse -command "submit $ORIGIN" "$ORIGIN..HEAD"
        if [ -n "$detached" ]; then
            git checkout $detached
            git branch -D submit-autodetach
        fi
        exit 0
    else
        RESOLVED_CHANGES=""
        for change in $IN_CHANGES; do
            SHA1=`git rev-parse "$change"`
            RESOLVED_CHANGES="$RESOLVED_CHANGES $SHA1"
        done
        IN_CHANGES="$RESOLVED_CHANGES"
    fi

    [ -z "$BRANCH" ] && BRANCH="$ORIGIN"
    if [ -z "$BRANCH" ]; then
        echo "No tracking branch!"
        exit 1
    fi

    stashed=
    if [ -n "$AUTOSTASH" ] && [ -n "`git status -s -uno 2>/dev/null`" ]; then
        ignore_marker=`git ignore-commit marker 2>/dev/null`
        git commit -a -m "${ignore_marker}git-submit" --allow-empty
        stashed=`git rev-parse HEAD`
    fi

    COMMON_SHA1=`git merge-base HEAD $BRANCH`
    CHANGES=""
    for change in $IN_CHANGES; do
        SHA1=`git rev-parse --short "$change"`
        if ! git merge-base "$SHA1" HEAD >/dev/null 2>/dev/null ; then
            echo "$SHA1 does not appear to be in the current branch"
            continue
        elif git ignore-commit check "$SHA1" >/dev/null; then
            echo "$SHA1 is marked to ignore!"
            continue
        fi
        CHANGES="$CHANGES $SHA1"
    done

    export CHANGES
    export GIT_SEQUENCE_EDITOR="$0"
    SKIPPED=`git rebase -i "${COMMON_SHA1}" | grep "skipped line" | wc -l | awk '{print $1}'` || exit 1
    NEW_SHA1=`git rev-parse HEAD~$SKIPPED`
    echo "Change: $NEW_SHA1"

    if [ -n "$NEW_SHA1" ] && [ "$PUSH" = "yes" ]; then
        PUSH_ORIGIN="."
        PUSH_BRANCH="$BRANCH"
        if echo "$PUSH_BRANCH" | grep -q "/"; then
            PUSH_ORIGIN=`echo $PUSH_BRANCH | cut -d/ -f1`
            PUSH_BRANCH=`echo $PUSH_BRANCH | cut -d/ -f2-`
        fi
        if [ ! -x "$GITROOT/hooks/pre-submit" ] || "$GITROOT/hooks/pre-submit" "$NEW_SHA1" "$BRANCH"; then
            echo "Push: $NEW_SHA1 -> $PUSH_BRANCH($PUSH_ORIGIN)"
            if git push $PUSH_ORIGIN "$NEW_SHA1:$PUSH_BRANCH"; then
                [ -x "$GITROOT/hooks/post-submit" ] && "$GITROOT/hooks/post-submit" "$COMMON_SHA1" "$BRANCH"
            fi
        fi
    fi
    if [ -n "$detached" ]; then
        git checkout "$detached"
        git branch -D submit-autodetach
        if [ -n "$stashed" ]; then
            git cherry-pick --allow-empty "$stashed"
        fi
    fi
    if [ -n "$stashed" ]; then
        git reset HEAD~
    fi
fi
exit 0
