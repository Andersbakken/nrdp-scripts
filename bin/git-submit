#!/bin/bash

show_help() {
    cat <<'EOF'
git-submit - Selectively submit commits to a branch

USAGE:
    git-submit tracking [BRANCH]
    git-submit changes|list [--branch BRANCH]
    git-submit [OPTIONS] [COMMIT...]
    git-submit [OPTIONS] -a

DESCRIPTION:
    git-submit extracts specific commits from your current branch, rebases them
    onto a target branch, and pushes them. This is useful for submitting a subset
    of commits while keeping others local.

COMMANDS:
    tracking [BRANCH]      Get or set the tracking branch
    changes, list          List commits that differ from tracking branch
                           Options: --branch BRANCH

SUBMIT OPTIONS:
    -h, --help             Show this help message
    -n, --dry-run          Show what would be pushed without actually pushing
    -f, --force            Force push
    --force-with-lease     Force push with lease
    -d                     Delete submitted commits from local branch after push
    -a                     Submit all commits that differ from tracking branch
    -r, --replace          Replace existing pull request (requires --pr)

    --branch, --src-branch BRANCH
                           Target remote branch to push to (also used to check
                           for existing commits and as base for rebasing)
    --dst-branch BRANCH    Override target branch (takes precedence over --src-branch;
                           default: tracking branch)
    --tracking BRANCH      Override tracking branch for this operation

    --pr, --pull-request NAME
                           Submit to a pull request

    --autostash            Auto-stash uncommitted changes
    --no-reset             Don't reset back to original state after push;
                           leaves submit commits at the beginning of the branch
                           with remaining commits reordered after them
    --reset                Reset back to original state after push (default)
                           Useful to override submit.reset=false config
    --abort-on-failure     Abort rebase on conflict (restores original state)
    --no-abort-on-failure  Leave rebase in progress on conflict for manual resolution
    --no-sync-check        Skip sync check with source branch
    --no-ignore-check      Don't skip commits marked as ignored
    --no-hooks             Skip git hooks (pre-submit, post-submit)

    --                     Treat remaining arguments as commit hashes

EXAMPLES:
    # Set tracking branch
    git-submit tracking origin/master

    # List commits that would be submitted
    git-submit changes

    # Submit specific commits
    git-submit abc123 def456

    # Submit all commits interactively (launches chooser)
    git-submit

    # Submit all commits automatically
    git-submit -a

    # Submit and delete from local branch
    git-submit -d abc123

    # Submit to a pull request
    git-submit --pr my-feature abc123 def456

    # Dry run to see what would be pushed
    git-submit -n abc123

    # Submit commit range
    git-submit abc123..def456

CONFIGURATION:
    submit.reset           Default reset behavior (default: true)
                           Set to false to default to --no-reset mode
    submit.abortOnFailure  Abort rebase on conflict (default: false)
                           Set to true to auto-abort failed rebases

NOTES:
    - If no commits are specified, an interactive chooser is launched
    - Commits marked as ignored are skipped unless --no-ignore-check is used
    - Git hooks (pre-submit, post-submit) are run if they exist
    - The script uses git rebase internally to extract commits

EOF
    exit 0
}

if test "x$GIT_SEQUENCE_EDITOR" = "x$0" ; then
    # The script was launched as an $EDITOR from git rebase -i.
    # Modify the pick line to an edit line and just exit.
    rm -f /tmp/commits$$
    touch /tmp/commits$$
    if [ "$SUBMIT_CHANGES_MODE" = "keep" ]; then
        for change in $SUBMIT_CHANGES; do
            echo "pick $change" >> /tmp/commits$$
        done
    elif [ "$SUBMIT_CHANGES_MODE" = "reorder" ]; then
        for change in $SUBMIT_CHANGES; do
            echo "pick $change" >> /tmp/commits$$
        done
        grep "^pick " "$1" | while read line; do
            found=
            for change in $SUBMIT_CHANGES; do
                if echo $line | grep --quiet "^pick $change"; then
                    found=1
                    break
                fi
            done
            if [ -z "$found" ]; then
                echo $line >> /tmp/commits$$
            fi
        done
    elif [ "$SUBMIT_CHANGES_MODE" = "delete" ]; then
        grep "^pick " "$1" | while read line; do
            found=
            for change in $SUBMIT_CHANGES; do
                if echo $line | grep --quiet "^pick $change"; then
                    [ "$SUBMIT_CHANGES_MODE" = "delete" ] && echo "drop $change" >> /tmp/commits$$
                    found=1
                    break
                fi
            done
            if [ -z "$found" ]; then
                echo $line >> /tmp/commits$$
            fi
        done
    fi
    cat /tmp/commits$$ > "$1"
    rm -f /tmp/commits$$
    exit 0
fi

GITHOOKSDIR=`git rev-parse --git-path hooks 2>/dev/null`
[ -z "$GITHOOKSDIR" ] && GITHOOKSDIR="$(git rev-parse --git-dir)/hooks"
CURRENTBRANCH=`git branch | grep '^\*' | awk '{print $2}' -`
if test "$CURRENTBRANCH" = "(no" ; then
    echo "Not on a valid branch - please check out the correct branch"
    exit 1
fi

run_hook() {
    [ -d "$GITHOOKSDIR" ] || return 0
    local HOOK_SCRIPT="${GITHOOKSDIR}/${1}"
    #echo "Running hook: ${HOOK_SCRIPT}"
    if [ -x "$HOOK_SCRIPT" ]; then
        shift
        $HOOK_SCRIPT "$@" || return 1
    fi
    return 0
}

TRACKING=`git config --local submit.tracking`
[ -z "$TRACKING" ] && TRACKING=`git tracking`

if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
elif [ "$1" = "tracking" ]; then
    if [ -n "$2" ]; then
        git config --local submit.tracking "$2"
    else
        echo "$TRACKING"
    fi
elif [ "$1" = "changes" ] || [ "$1" = "list" ]; then
    BRANCH=""
    while [ "$#" -ge 1 ]; do
        if [ "$1" = "--branch" ]; then
            shift
            BRANCH="$1"
        fi
        shift
    done
    [ -z "$BRANCH" ] && BRANCH="$TRACKING"

    for change in `git cherry $BRANCH | grep '^+ ' | sed 's,^+,,g'`; do
        [ "$change" = "+" ] && continue
        NOTES=
        git ignore-commit check "$change" >/dev/null && NOTES="$NOTES [IGNORED]"
        echo "$(git changes --no-ignores --max-count=1 $change)$NOTES"
    done
else
    PR=""
    SRC_BRANCH=""
    DST_BRANCH="$TRACKING"
    ALL=no
    IN_CHANGES=
    DELETE=no
    FORCE=
    REPLACE=no
    PUSH=yes
    IGNORE_CHECK=yes
    SYNC_CHECK=yes
    AUTOSTASH=
    OPERATION=`git config submit.operation`
    if [ "$OPERATION" = "0" ] || [ "$OPERATION" = "false" ]; then
        OPERATION=
    fi
    [ "`git config submit.autostash`" != "false" ] && AUTOSTASH="yes"
    RESET_DEFAULT=`git config submit.reset`
    if [ "$RESET_DEFAULT" = "false" ] || [ "$RESET_DEFAULT" = "0" ]; then
        NO_RESET=yes
    fi
    ABORT_ON_FAILURE_DEFAULT=`git config submit.abortOnFailure`
    if [ "$ABORT_ON_FAILURE_DEFAULT" = "true" ] || [ "$ABORT_ON_FAILURE_DEFAULT" = "1" ]; then
        ABORT_ON_FAILURE=yes
    fi
    while [ "$#" -ge 1 ]; do
        if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
            show_help
        elif [ "$1" = "-n" ] || [ "$1" = "--dry-run" ]; then
            PUSH=no
        elif [ "$1" = "-f" ] || [ "$1" = "--force" ];  then
            FORCE="-f"
        elif [ "$1" = "--force-with-lease" ];  then
            FORCE="--force-with-lease"
        elif [ "$1" = "-d" ]; then
            DELETE=yes
        elif [ "$1" = "--branch" ] || [ "$1" = "--src-branch" ]; then
            shift
            SRC_BRANCH="$1"
        elif [ "$1" = "--tracking" ]; then
            shift
            TRACKING="$1"
        elif [ "$1" = "--dst-branch" ]; then
            shift
            DST_BRANCH="$1"
        elif [ "$1" = "--pr" ] || [ "$1" = "--pull-request" ]; then
            shift
            PR="$1"
        elif [ "$1" = "--replace" ] || [ "$1" = "-r" ]; then
            REPLACE=yes
        elif [ "$1" = "--autostash" ]; then
            AUTOSTASH="yes"
        elif [ "$1" = "--no-sync-check" ]; then
            SYNC_CHECK="no"
        elif [ "$1" = "--no-ignore-check" ]; then
            IGNORE_CHECK="no"
        elif [ "$1" = "--no-hooks" ]; then
            GITHOOKSDIR=""
        elif [ "$1" = "--no-reset" ]; then
            NO_RESET=yes
        elif [ "$1" = "--reset" ]; then
            NO_RESET=
        elif [ "$1" = "--abort-on-failure" ]; then
            ABORT_ON_FAILURE=yes
        elif [ "$1" = "--no-abort-on-failure" ]; then
            ABORT_ON_FAILURE=
        elif [ "$1" = "-a" ]; then
            ALL=yes
        elif [ "$1" = "--" ]; then
            shift
            IN_CHANGES="$IN_CHANGES $@"
            break
        elif `echo $1 | grep --quiet -- "^-"`; then
            echo "git-submit: Unknown option $1" >&2
            exit 1
        else
            IN_CHANGES="$IN_CHANGES $1"
        fi
        shift
    done
    if [ "$ALL" = "yes" ]; then
        for change in `git cherry "$TRACKING" | grep '^+ ' | sed 's,^+,,g'`; do
            IN_CHANGES="$IN_CHANGES `echo $change | awk '{print $1}'`"
        done
    fi
    if [ -n "$PR" ]; then
        PR_ARGS=""
        [ -n "$PR" ] && PR_ARGS="$PR_ARGS --name $PR"
        [ "$REPLACE" = "yes" ] && PR_ARGS="$PR_ARGS --force"
        git pullrequest submit ${PR_ARGS} ${IN_CHANGES}
        exit 0
    elif [ "$REPLACE" = "yes" ]; then
        echo "--replace only works with --pr"
        exit 1
    fi
    autostash() {
        if [ -n "$AUTOSTASH" ] && [ -n "`git status -s -uno 2>/dev/null`" ]; then
            ignore_marker=`git ignore-commit marker 2>/dev/null`
            git commit -a -m "${ignore_marker}git-submit" --allow-empty
            return 0
        fi
        return 1
    }
    if [ "$SYNC_CHECK" = "yes" ] && [ -n "$SRC_BRANCH" ] && ! git sync --check "$SRC_BRANCH" >/dev/null 2>&1; then
        echo "You need to sync first! [$SRC_BRANCH]" >&2
        exit 1
    fi

    if [ -z "$SRC_BRANCH" ]; then
        SRC_BRANCH="$DST_BRANCH"
    fi
    if [ -z "$SRC_BRANCH" ]; then
        echo "No branch to push to!"
        exit 1
    fi

    COMMON_SHA1_BRANCH="$SRC_BRANCH"
    git rev-parse "$COMMON_SHA1_BRANCH" >/dev/null 2>&1 || COMMON_SHA1_BRANCH="$TRACKING"
    COMMON_SHA1=`git merge-base HEAD $COMMON_SHA1_BRANCH`

    if [ -z "$IN_CHANGES" ]; then
        SUBMIT_ARGS="--tracking ${TRACKING}"
        #SUBMIT_ARGS="${SUBMIT_ARGS} --no-hooks"
        [ -n "$FORCE" ] && SUBMIT_ARGS="$SUBMIT_ARGS $FORCE"
        [ "$DELETE" = "yes" ] && SUBMIT_ARGS="$SUBMIT_ARGS -d"
        [ -n "$SRC_BRANCH" ] && SUBMIT_ARGS="$SUBMIT_ARGS --src-branch ${SRC_BRANCH}"
        [ -n "$DST_BRANCH" ] && SUBMIT_ARGS="$SUBMIT_ARGS --dst-branch ${DST_BRANCH}"
        [ "$SYNC_CHECK" != "yes" ] && SUBMIT_ARGS="$SUBMIT_ARGS --no-sync-check"
        [ "$IGNORE_CHECK" != "yes" ] && SUBMIT_ARGS="$SUBMIT_ARGS --no-ignore-check"
        which git-choose-show-change >/dev/null 2>&1 && git-choose-show-change --filter "$SRC_BRANCH" --reverse --command "submit ${SUBMIT_ARGS}" "${TRACKING}..HEAD"
        exit 0
    else
        RESOLVED_CHANGES=""
        for change in $IN_CHANGES; do
            if echo "$change" | grep -q '\.\.'; then
                # Range notation (e.g., HASH1..HASH2) - expand using git log
                RANGE_COMMITS=$(git log --reverse --pretty='%H' "$change" 2>/dev/null)
                if [ $? -ne 0 ] || [ -z "$RANGE_COMMITS" ]; then
                    echo "git-submit: Failed to resolve range '$change'" >&2
                    exit 1
                fi
                for SHA1 in $RANGE_COMMITS; do
                    RESOLVED_CHANGES="$RESOLVED_CHANGES $SHA1"
                done
            else
                SHA1=$(git rev-parse "$change" 2>/dev/null)
                if [ $? -ne 0 ] || [ -z "$SHA1" ]; then
                    echo "git-submit: Failed to resolve commit '$change'" >&2
                    exit 1
                fi
                RESOLVED_CHANGES="$RESOLVED_CHANGES $SHA1"
            fi
        done
        IN_CHANGES="$RESOLVED_CHANGES"
    fi

    AUTOSTASHED=0
    autostash && AUTOSTASHED=$((AUTOSTASHED+1))
    RESET_HEAD=`git rev-parse HEAD`

    CHANGES=""
    for change in $IN_CHANGES; do
        SHA1=`git rev-parse --short "$change"`
        if ! git merge-base "$SHA1" HEAD >/dev/null 2>/dev/null ; then
            echo "$SHA1 does not appear to be in the current branch"
            continue
        elif [ "$IGNORE_CHECK" = "yes" ] && git ignore-commit check "$SHA1" >/dev/null; then
            echo "$SHA1 is marked to ignore!"
            continue
        fi
        if git rev-parse "$SRC_BRANCH" >/dev/null 2>&1; then
            FILTER_CHERRY=$(git cherry "$SRC_BRANCH" "${SHA1}" "${SHA1}~" 2>/dev/null)
            if [ -z "${FILTER_CHERRY}" ] || echo "$FILTER_CHERRY" | grep -q '^-'; then
                echo "Filtered: ${SHA1}" >&2
                continue
            fi
        fi
        CHANGES="$CHANGES $SHA1"
    done

    export SUBMIT_CHANGES="$CHANGES"
    if [ -z "$FORCE" ] && git rev-parse "$SRC_BRANCH" >/dev/null 2>&1; then
        for h in $(git log --reverse --pretty='%h' "${COMMON_SHA1}..${SRC_BRANCH}"); do
            export SUBMIT_CHANGES="$h $SUBMIT_CHANGES"
        done
    fi
    if [ "$NO_RESET" = "yes" ]; then
        export SUBMIT_CHANGES_MODE="reorder"
    else
        export SUBMIT_CHANGES_MODE="keep"
    fi
    export GIT_SEQUENCE_EDITOR="$0"
    echo "${SUBMIT_CHANGES_MODE^} ${SUBMIT_CHANGES} onto ${COMMON_SHA1}"
    #exit 0
    [ -n "$OPERATION" ] && git operation save
    if ! git rebase --keep-empty -i "${COMMON_SHA1}"; then
        echo "Git failed"
        if [ "$ABORT_ON_FAILURE" = "yes" ]; then
            echo "Aborting rebase..."
            git rebase --abort
            git reset --hard "${RESET_HEAD}"
            [ "$AUTOSTASHED" -gt 0 ] && git reset "HEAD~${AUTOSTASHED}"
        fi
        [ -n "$OPERATION" ] && git operation pop
        exit 1
    fi
    if [ "$NO_RESET" = "yes" ]; then
        SUBMIT_COUNT=$(echo $SUBMIT_CHANGES | wc -w)
        TOTAL_COUNT=$(git rev-list --count "${COMMON_SHA1}..HEAD")
        SKIP_COUNT=$((TOTAL_COUNT - SUBMIT_COUNT))
        NEW_SHA1=`git rev-parse "HEAD~${SKIP_COUNT}"`
    else
        NEW_SHA1=`git rev-parse HEAD`
    fi
    if [ -z "$NEW_SHA1" ]; then
        echo "Nothing to push"
        DELETE="no"
    else
        PUSH_ORIGIN="."
        PUSH_BRANCH="$DST_BRANCH"
        [ -z "$PUSH_BRANCH" ] && PUSH_BRANCH="$SRC_BRANCH"
        if echo "$PUSH_BRANCH" | grep -q "/"; then
            PUSH_ORIGIN=`echo $PUSH_BRANCH | cut -d/ -f1`
            PUSH_BRANCH=`echo $PUSH_BRANCH | cut -d/ -f2-`
        fi
        PUSH_ARGS="$PUSH_ORIGIN $NEW_SHA1:refs/heads/$PUSH_BRANCH"
        [ -n "$FORCE" ] && PUSH_ARGS="$FORCE ${PUSH_ARGS}"
        echo "Push: git push $PUSH_ARGS"

        if [ "$PUSH" = "yes" ] && run_hook "pre-submit" "$NEW_SHA1" "$SRC_BRANCH"; then
            if git push ${PUSH_ARGS}; then
                run_hook "post-submit" "$COMMON_SHA1" "$SRC_BRANCH" "$TRACKING"
            else
                DELETE="no"
            fi
        fi
    fi
    if [ "$NO_RESET" != "yes" ]; then
        git reset --hard "${RESET_HEAD}"
        if [ "$DELETE" = "yes" ] && [ "$PUSH" = "yes" ]; then
            export SUBMIT_CHANGES="$CHANGES"
            export SUBMIT_CHANGES_MODE="delete"
            echo "Delete ${SUBMIT_CHANGES} from ${COMMON_SHA1}"
            git rebase -i "${COMMON_SHA1}" >/dev/null
        fi
    fi
    [ "$AUTOSTASHED" -gt 0 ] && git reset "HEAD~${AUTOSTASHED}"
    [ -n "$OPERATION" ] && git operation pop
fi
exit 0
